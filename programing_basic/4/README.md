# 问题求解与算法设计基础1 
>
## 1 分治
>
### 分治的基本思想
>
#### 分治（Divide and Conquer）
>
- 分而治之，是处理复杂问题的一个最基本、也最常用的策略之一
>
#### 基本思想
>
- 规模为N原始问题——>规模较小的同类子问题——>规模更小的同类子问题——>直接求解
>
- 将各个子问题的解合并为原问题的解
>
### 分治的实例——找假币
>
- 有12枚一模一样的硬币，已知其中只有一枚是假币，并且假币和真币的重量不一样（假设已知假币比真币重量轻），问如何用一个天平把假币从这12枚硬币中找出来，要求只能称3次。
>
- 最简单的可直接求解的找假币问题：只有2枚，称1次
>
- 稍复杂一点的：只有3枚，需要称几次？
>
- 分治法 + 排除法
>
#### 情形1
>
- （1）把12枚硬币分成两等份，每份6枚；
- （2）把有假币的那端的6枚硬币再分成两等份，每份3枚；
- （3）在有假币的那一端的3枚硬币中任取2个去称重。
>
#### 情形2
>
- （1）把12枚硬币分成三等份，每份4枚；
- （2）在有假币的那一端的4枚硬币中，任取两枚放到天平两端去称重；
- （3）若假币在余下的那两枚中，则把这两枚硬币放到天平两端去称重。
>
### 典型的分治的方法
>
#### 最常用的是二分法
>
- **每次将原问题分解为两个子问题**
>
- 一分为二的哲学思想的应用
- - 许多经典的算法，归并排序、折半查找、二分法求方程的根等
>
- **合并是算法的关键**
>
- 无统一的模式
>
#### 用分治策略设计的算法，通常用递归程序来实现
>
### 分治的实例——归并排序
>
![](https://github.com/lufeil/mooc/blob/master/programing_basic/4/pic/01.png)
>
![](https://github.com/lufeil/mooc/blob/master/programing_basic/4/pic/02.png)
>
- 将相邻两个有序数列合并成一个新的有序数列：
>
- 总是取两个剩余序列中排在前面的最小数放到合并后的序列中
>
### 分治法给我们的哲学思考
>
- “换一个角度”一分为二地观察和思考问题
>
#### 化繁为简
####          化难为易
####                  化大为小
####                          化未知为已知
>
## 穷举
>
### 穷举法的基本思想
>
#### 穷举法（Exhaustion），也称枚举法（Enumeration）
>
- 列举所有可能，逐一试探
>
#### 基本思想
>
- 根据问题的部分已知条件预估解的范围
>
- 在此范围内对所有可能的情况进行逐一验证
- - 若某个情况符合题目的全部条件，则该情况为本问题的一个解
- - 若全部情况的验证结果均不符合题目的全部条件，则说明该题无解
>
- 直到找到满足已知条件的解为止
>
### 穷举法求解问题的两个基本要素
>
#### 确定穷举对象和穷举范围
>
- 影响算法的时间复杂度
>
- 循环结构实现
>
#### 确定判定条件
>
- 符合什么条件才能成为问题的答案
>
- 分支结构实现
>
### 穷举法的实际应用
>
#### 常用于密码的破译
>
- 将所有可能的密码逐个尝试，直到找出真正的密码为止 
>
#### 也称蛮力法（Brute Force），或暴力搜索法
>
- 理论上利用这种方法可破解任何一种密码，问题在于如何缩短试误时间
- - 破译一个有8位且可能拥有大小写字母、数字及特殊字符的密码，用普通的PC机可能需要花费几个月甚至更长的时间
>
- 为防止非法用户使用穷举法破解密码，严密的密码验证机制都能设置可容许的试误次数
- - ATM柜员机，智能手机
>
### 穷举法的特点
>
#### 优点
>
- 优点：算法简单，逻辑清晰，易于理解，程序易于实现
>
#### 缺点
>
- 运算量较大
- 只适合于“有几种组合”、“是否存在”、求解不定方程等类型的问题求解
>
### 穷举法实例1——鸡兔同笼
>
- Problem：已知有鸡兔若干只，共有98个头，386只脚，请用穷举法编程计算鸡、兔各多少只。
>
- 确定问题的输入和输出
- - 输入：无；输出：鸡x只，兔y只
>
- 确定穷举对象：鸡和兔
>
- 确定搜索范围：x,y=1,2,…98
>
- 确定判定条件：x+y=98，2*x+4*y=386
>
#### Raptor实现
>
### 穷举法实例2——韩信点兵
>
- Problem：韩信有一队兵，士兵排队报数，按从1至5报数，最末一个士兵报的数为1；按从1至6报数，最末一个士兵报的数为5；按从1至7报数，最末一个士兵报的数为4；最后再按从1至11报数，最末一个士兵报的数为10。请问韩信至少有多少兵。
>
- 确定问题的输入和输出
- - 输入：无；输出：士兵至少x人
>
- 确定穷举对象：士兵数x
>
- 确定搜索范围：x从1变化……
>
- 确定判定条件：x被5、6、7、11整除余数为1、5、4、10
>
### 讨论
>
- 穷举法求解问题时，如果穷举范围没有上限，并且问题有可能无解时，结果会怎样？
>
- 鸡兔同笼问题的流程图错在哪里？
>
## 3 递推
>
### 递推法的基本思想
>
#### 递推法
>
- 利用问题本身所具有的一种递推关系来求解问题的一种方法
>
#### 递推
>
- 是指从已知的初始条件出发，依据某种递推关系，逐次推出所要计算的中间结果和最终结果
>
- - 初始条件要么在问题本身中已经给定
>
- - 要么需要通过对问题的分析和化简后来确定
>
### 递推的本质和特点
>
#### 递推的本质
>
- 把一个复杂的计算过程转化为一个简单过程的多次重复计算 
>
#### 可递推求解的问题的特点
>
- 问题可以划分成多个状态
>
- 除初始状态外，其它各状态都可用固定的递推关系式来表示
>
#### 递推的应用
>
- 常用于按照一定的规律来计算序列中的指定项
>
- 递推关系式通常不会直接给出
>
### 递推的方法
>
#### 正向顺推
>
- 从已知条件出发，向着所求问题前进，最后与所求问题联系起来
>
- 已知一个汉堡包12元，一个蛋挞比一个汉堡包贵5元，问买两种各一个需多少元？ 
>
#### 反向逆推
>
- 从所求问题出发，向着已知条件靠拢，最后与已知条件联系起来
>
- 从问题的结果出发，一步一步还原出答案
>
- 小明来到一家早餐店，拿出一半钱吃早餐，又花了3.5元买饮料，还剩1元，问他原来带了多少钱？
>
### 正向顺推的实例
>
#### 兔子的理想化繁衍问题（ 13世纪数学家Fibonacci ）
>
- 假设一对小兔的成熟期是一个月，即一个月可长成成兔，每对成兔每个月可生一对小兔，一对新生的小兔第二个月长成成兔就开始生小兔，问从一对成兔开始繁殖，一年后总计有多少对成兔和多少对小兔？
>
- 每个月兔子对数的变化规律——Fibonacci数列的递推公式
>
### 反向逆推的实例
>
#### 猴子吃桃问题
>
- 猴子第一天摘下若干个桃子，吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，并且又多吃了一个。以后每天早上都吃掉前一天剩下的一半零一个。到第10天早上再想吃时，发现只剩下一个桃子。问第一天共摘了多少桃子。
>
- 若猴子每天少吃1个（多剩1个），则每天剩下的桃子数将是前一天的一半
>
- 每天剩下的桃子数加1之后，刚好是前一天的一半
>
#### Raptor
>
### 思考
>
- 为了加强交互性，由用户输入不同的天数n进行递推，即假设第n天的桃子数为1，问第1天的桃子数是多少，其中n由用户从键盘输入。此时，流程图该如何修改呢？
>
- 如果要增加对用户输入数据的合法性验证（即不允许输入的天数是0和负数），那么流程图又该如何修改呢？
>
## 4 迭代1
>
### 迭代法的基本思想
>
#### 迭代法（Iterative Method），也称辗转法
>
- 通过迭代函数（迭代关系式、迭代公式）
>
- 由迭代变量旧值（前一个值）推出新值（下一个值），再不断用新值取代旧值
>
- 反复校正迭代变量的值
>
- 通过反复迭代，产生一个数列： x0, x1, , x2…, xn,…，直到逐步逼近问题的解
>
### 迭代法的基本步骤
>
#### 1）确定迭代变量
>
- 在可用迭代法求解的问题中，应至少存在一个可直接或间接地不断由旧值推出新值的变量——迭代变量
>
#### 2）建立迭代函数
>
- 解决迭代问题的关键
>
#### 3）确定迭代结束条件（收敛判据）
>
- （1）所需的迭代次数是已知的确定的值——计数控制的循环
>
- （2）所需的迭代次数无法确定——条件控制的循环
>
### 精确迭代
>
#### 通过迭代能够得到精确解
>
- 计算两个正整数的商和余数
>
- - 商和余数的关系：x = q \* y + r
- - 迭代变量：r
- - 迭代关系式：r = r –y
- - 迭代结束条件：r < y
>
#### Raptor 实现
>
### 近似迭代
>
#### 近似迭代
>
- 从一个初始估值出发迭代产生一系列离解越来越近的近似解
>
- 近似求解非线性方程的根
>
- - 利用求根公式——直接求解方程的精确解
- - 但非线性方程很难直接求得精确的数值解，往往只要求得到满足一定精度要求的近似解
>
- 直接迭代法就最简单的迭代法——简单迭代法
>
### 直接迭代法
>
- 直接迭代法求方程f(x)=0的根的基本思路
>
- 确定迭代变量：x
>
- 建立迭代函数：x=g(x)
- - f(x)=0 ——> x=g(x)
- - 求 f(x) = 0 的根 ——> 求 x = g(x) 的根
>
### 直接迭代法的几何意义是什么？
>
- 
>
### 直接迭代法的收敛性
>
#### 什么情况下，迭代过程不收敛？
>
- 1）方程无解
>
- 2）虽然方程有解，但迭代公式选择不当，或迭代初值选择不合理
>
### 直接迭代法实例
>
- 用直接迭代法求一元二次方程x2-x-1=0在\[1,3\]之间的根
>
## 5 迭代2
>
### 牛顿迭代法
>
#### 直接迭代法
>
- 迭代函数可从方程直接导出，迭代函数的构造有多种方法
>
- 并非所有的都能使迭代收敛
>
#### 牛顿迭代法
>
- 牛顿在17世纪提出的一种在实数域和复数域上近似求解非线性方程的方法
>
- 实质：以“直”代“曲”
>
### 牛顿迭代法的实质
>
- 
>
### 牛顿迭代法的数学意义
>
- 
>
### 牛顿迭代法实例
>
- 用牛顿迭代法求一元二次方程x2-x-1=0在\[1,3\]之间的根
>
#### Raptor实例
>
### 牛顿迭代法
>
#### 优点
>
- 收敛很快，在单根附近二阶收敛，在重根附近线性收敛
>
- 可求复根
>
#### 缺点
>
- 对重根收敛较慢
>
- 要求函数的一阶导数存在，并且不能为0
>
## 6 递归
>
### 递归
>
#### 如果一个对象部分地由它自己组成或按它自己定义，则称它是递归的（Recursive）
>
#### 递归（Recursion）
>
- 函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象
>
### 递归 – 阶乘
>
### 递归算法必须包含如下两个部分：
>
- 由其自身定义的与原始问题类似的更小规模的子问题，它使递归过程持续进行，称为**一般条件**（General case）
>
- 所描述问题的最简单的情况，它是一个能控制递归过程结束的条件，称为**基本条件**（Base case）
>
#### 在印度，有这么一个古老的传说:
>
- 开天辟地的神勃拉玛（和中国的盘古差不多的神）在一个庙里留下了三根金刚石的棒，第一根上面套着64个圆的金片，最大的一个在底下，其余一个比一个小，依次叠上去，庙里的众僧不倦地把它们一个个地从这根棒搬到另一根棒上，规定可利用中间的一根棒作为帮助，但每次只能搬一个，而且大的不能放在小的上面
>
### 递归 - 汉诺塔
>
#### 第1步：将问题简化——复杂问题求解的基本方法
>
#### 第2步：对有 n（n>1）个圆盘的汉诺塔，将n个圆盘分为两部分，“上面n-1个圆盘”看成一个整体
>
### 递归
>
#### 优势
>
- 逻辑清楚，结构清晰，可读性好，更逼近数学公式的表示，符合人的思维习惯，能使一个蕴含递归关系且结构复杂的程序简洁精炼
>
- 特别是在难于找到从边界到解的全过程的情况下，如果把问题推进一步,其结果仍维持原问题的关系
>
#### 劣势
>
- 嵌套层次深，函数调用开销大
>
- 重复计算
>
### 特别适合于使用递归算法的三种情况：
>
- 数学定义递归的，如计算阶乘、最大公约数和Fibonacci数列等
>
- 数据结构是递归的，如队列、链表、树和图等
>
- 问题的解法是递归的，如Hanoi塔，骑士游历、八皇后问题等
>
### 递归 – 盗梦空间
>
![](https://github.com/lufeil/mooc/blob/master/programing_basic/4/pic/03.png)
>
















