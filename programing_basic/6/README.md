# 问题求解与算法设计基础3 
>
## 1 冒泡排序
>
### 冒泡法排序
>
- 比较相邻的两个数据若顺序不对，则将其位置交换 
>
## 2 交换、选择排序
>
### 交换法排序
>
- 第一个数分别与后面所有的数进行比较，若后面的数较小，则交换后面这个数和第一个数的位置
>
- 第二个数分别与后面所有的数进行比较，若后面的数较小，则交换后面这个数和第二个数的位置 
>
### 选择法排序
>
- 在每一遍比较中，在剩余的待比较的数中选择一个最小的数与这个剩余序列的第1个数交换位置 
>
### 时间复杂度
>
#### 选择排序是一种有效的排序算法吗？
>
#### 所需步骤
>
- 找到最小的元素需要 n 步
>
- 找到剩余的最小元素需要 n-1 步
>
- ...
>
#### 总运行时间
>
- n + (n – 1) + … + 2 + 1 
>
#### 随着n的增大，n和算法性能之间的关系称为算法的计算复杂度（Computational Complexity）
>
#### 时间复杂度（Time Complexity）和空间复杂度（Space Complexity）
>
#### 算法的时间复杂度是算法的时间量度，是指执行算法所需要的计算工作量
>
#### 一个算法花费的时间与算法中语句的执行次数是成正比的，
>
#### 算法的基本操作被重复执行的次数是问题规模n的某个函数f(n)，因此，算法的时间复杂度记为：T(n)=O(f(n)) 
>
#### O(n2)表示算法性能随问题规模n 的平方而变化
>
#### 常用的时间复杂度从低到高的次序如下
>
- O(1) < O(logn) < O(n) < O(n2) < O(n3) < O(2n) 
>
### 冒泡排序的时间复杂度
>
#### 所需步骤
>
- 从前往后的一次冒泡需要 n 步
>
- 在剩余的数据中再进行一次冒泡需要 n-1 步
>
- ……
>
#### 总运行时间
>
- n + (n – 1) + … + 2 + 1
>
##### 时间复杂度
>
- O(n2) 
>
## 3 插入、希尔排序
>
### 插入法排序
>
- 每次将一个待排序的数据，在前面已排好序的子序列中从后向前扫描，按其值大小找到适当的位置并插入其中，直到序列中的全部数据都插入完毕为止 
>
### 希尔法排序 
>
- 取一个小于n的整数d1作为第一个增量，把序列中的全部数据分成d1个组。所有距离为d1的倍数的数据放在同一个组中；
>
- 在各组内进行直接插入排序；
>
- 取第二个增量d2<d1，重复上述的分组和排序，直至所取的增量dt=1(dt<…<d2<d1)，即所有数据都放在同一组中进行直接插入排序为止。
>
#### 实质是一种分组插入方法
>
## 4 归并排序
>
### 归并法排序
>
- 假设待排序的数据序列中有n个数据，可以先将序列看成是由n个长度为1的有序子序列组成
>
- 然后再两两子序列合并，得到一个n/2个长度为2或1（当序列中数据为奇数时会有一个子序列长度为1）的有序子序列，
>
- 再两两子序列合并，如此重复，直到得到一个长度为n的有序序列为止 
>
## 5 快速排序
>
### 快速法排序
>
- 1 设置两个变量i和j，排序开始前将i和j分别初始化为1和n，这里i和j分别相当于序列的左指针和右指针；
>
- 2 以序列中第一个数作为基准（Base），赋值给s，这里基准相当于序列分割的一个参照物；
>
- 3 从j开始从后向前搜索，每向前搜索一步，就将j的值减去1，直到搜索到第一个小于s的数为止，将这个数和基准互换位置；
>
- 4 从i开始从前向后搜索，每向后搜索一步，就将i的值加上1，直到搜索到第一个大于s的数为止，将这个数和基准互换位置；
>
- 5 重复第3、4步，直到i与j相等为止。
>
