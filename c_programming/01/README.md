# 初识C语言从认识变量和常量开始 
>
## 1 为什么要学习C语言
>
### 是一种高级语言
>
- 并不“高级”，只是相对低级语言在一个高的级别上进行编程
>
- 实际上是一种介于高级语言和低级语言之间的语言，运行效率高
>
- 透过现象看本质，透过C语言窥探计算机底层原理
>
### 很多流行语言、新生语言都借鉴了它的思想、语法
>
- 从C++，到Java，再到C#
>
- 学好C是学习这些流行语言的基础，了解程序设计的基本思想
>
- 交流、笔试、面试时最常见的语言
>
### 历史悠久，战勋卓著
>
- 诞生于20世纪70年代初
>
- 成熟于80年代
>
- 很多重量级软件都是用C语言写的，维护已有的C代码
>
### 上天入地，无所不能
>
- 几乎没有不能用C语言实现的软件
>
- 没有不支持C语言的系统
>
### 选语言的标准——适合的才是最好的
>
- 编写系统软件（例如OS）和工具软件
>
- 运行效率要求较高的系统
>
- - 设备驱动程序，嵌入式系统（Embedded systems）（机器人、手机和智能家电等 ）
- - 高性能、实时系统（Real-time systems）
>
### 程序开发步骤
>
- 分析——>设计——>编码——>编译连接——>运行——>测试调试——>维护修改
>
![](https://github.com/lufeil/mooc/blob/master/c_programming/01/pic/01.png)
>
## 2 变量的定义
>
![](https://github.com/lufeil/mooc/blob/master/c_programming/01/pic/02.png)
>
### 变量必须先定义，后使用
>
### 变量的4个基本属性
>
#### 变量名（Name）
>
#### 变量的值（Value）
>
#### 变量的类型（Type）
>
#### 变量的地址（Address）
>
## 3 变量的类型决定了什么？
>
### 数据类型（Data Type）
>
#### 在冯·诺依曼体系结构中
>
- 程序代码和数据都是以二进制存储的
>
- 对计算机系统和硬件本身而言，数据类型的概念并不存在
>
#### 问题：高级语言为什么要区分数据类型
>
- 更有效地组织数据，规范数据的使用
>
- 有助于提高程序的可读性，方便用户的使用
>
#### 在程序设计语言中引入数据类型的好处
>
- 带来了程序的简明性和数据的可靠性
>
- 有助于提高程序执行效率、节省内存空间
>
### C语言中的数据类型
>
#### 基本类型
>
- **整型**：基本整型、长整型、短整型、无符号整型
>
- **实型**（浮点型）：单精度实型、双精度实型、长双精度实型
>
- **字符型**
>
- **枚举类型**
>
#### 构造类型
>
- **数组类型**
>
- **结构体类型**
>
- **共用体类型**
>
#### 指针类型
>
#### 空类型
>
### 变量的类型决定了什么？
>
- 占用内存空间的大小
>
- 数据的存储形式
>
- 合法的表数范围
>
- 可参与的运算种类
>
### 如何计算变量或类型占内存的大小
>
#### 问题：如何计算变量占内存空间的大小？
>
- 用sizeof运算符
>
- 一元运算符
>
#### 用sizeof运算符计算变量占内存空间的大小的好处
>
- 增加程序的可移植性
>
- 编译时执行的运算符，不会导致额外的运行时间开销
>
### 不同类型数据的存储形式
>
#### 小端次序
>
- 便于计算机从低位字节向高位字节运算
>
#### 大端次序
>
- 与人们从左到右的书写顺序相同，便于处理字符串
>
#### 如何存储实型数呢？
>
- 关键：确定小数点的位置
>
#### 问题：如何表示实型数？
>
- 小数形式
>
- 指数形式——科学计数法
>
- **定点数**（Fixed Point）
>
- - 小数点的位置固定
>
- **浮点数**（Floating-Point）
>
- - 小数点的位置不固定
>
#### 浮点数实现小数点位置可浮动的主要原因
>
- 将实数拆分成了**阶码**（Exponent）和**尾数**（Mantissa）分别存储
>
- 对于同样的尾数，阶码的值越大，则浮点数所表示的数值的绝对值就越大
>
![](https://github.com/lufeil/mooc/blob/master/c_programming/01/pic/03.png)
>
### 不同数据类型可参与的运算不同
>
#### 整型
>
- 加、减、乘、除、求余
>
#### 实型
>
- 加、减、乘、除
>
#### 字符型
>
- 加、减（整数）
>
- 对ASCII码值的运算
>
#### 指针类型
>
- 加、减（整数）和比较运算
>
## 小结
>
### 不同类型的变量
>
#### 占用内存空间的大小不同
>
- 用sizeof运算符计算变量占内存空间
>
#### 数据在内存中的存储形式不同
>
#### 合法的表数范围不同
>
#### 可参与的运算种类 不同
>
## 3 常量
>
### 计算圆的面积和周长
>
```
#include <stdio.h>
main()
{
  printf("area = %f\n", 3.14159*5.3*5.3);
  printf("circumference = %f\n", 2*3.14159*5.3);
}
```
>
#### 在程序中直接使用的常数，称为幻数(Magic Number)
>
#### 问题：使用幻数存在什么问题？
>
- 程序的可读性变差
>
- 容易发生书写错误，产生不一致性
>
- 当常数需要改变时，要修改所有引用它的代码，繁琐，还可能有遗漏
>
### 如何避免在程序中使用幻数？
>
#### 良好的程序设计风格建议把幻数定义为
>
- 宏常量
>
- const常量
>
#### 优点
>
- 减少重复书写常数的工作量
>
- 提高程序的可读性和可维护性
>
### 宏常量
>
#### 宏常量（Macro Constant ）
>
- 用一个标识符号来表示的常量
>
#### 宏定义
>
- #define 标识符 字符串
>
#### 编译预处理命令
>
- 在源程序编译之前，先对程序中的编译预处理命令进行处理然后将处理的结果和源程序一起进行编译，以得到目标代码
>
```
#include <stdio.h>
#define PI 3.14159
#define R 5.3
main()
{
  printf("area = %f\n", PI * R * R);
  printf("circumference = %f\n", 2 * PI * R);
}
```
>
- 预编译时，将程序中出现的宏名全部替换为字符串——宏展开，宏替换 
>
- 宏替换以后，相当于执行 
>
```
#include <stdio.h>
main()
{
  printf("area = %f\n", PI * R * R );
  printf("circumference = %f\n", 2 * PI * R);
}
```
>
### 关键是“换”，不做语法检查 
>
### 宏常量存在的问题是什么？
>
- 没有数据类型，编译器在宏替换时不进行类型检查
>
- 只进行简单的字符串替换，极易产生意想不到的错误
>
### const常量
>
```
#include <stdio.h>
main()
{
   const double pi = 3.14159;
   const double r = 5.3;
   printf("area = %f\n", pi * r * r);
   printf("circumference = %f\n", 2 * pi * r);
}
```
>
#### 为什么只能在定义时赋初值
>
- 编译器将const常量放在只读存储区中，而只读存储区时不允许进行写操作的。
- 为什么要把const常量放在只读存储区中，因为它是一个常量，而常量是不允许在程序中改变其值的。
- 因此const常量只能在定义的时候赋初值。
>
#### const常量与宏常量相比的优点是什么？
>
- const常量有数据类型，编译器能对其进行类型检查
>
- 某些集成化调试工具可以对const常量进行调试
>
```
#include <stdio.h>
main()
{
   const float pi = 3.14159;
   const float r = 5.3;
   printf("area = %f\n", pi * r * r);
   printf("circumference = %f\n", 2 * pi * r);
}
```
>
#### 'initializing': truncation from 'const double' to 'const float'
>
#### 常量3.14159隐含按double型处理
>





